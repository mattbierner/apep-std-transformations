{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n    Common text transformations.\n*/\n\"use strict\";\nconst pep = require('apep');\n\nmodule.exports = (proto = {}) => \n    Object.create(proto, {\n        'match': { value: match },\n        'replace': { value: replace },\n        'upper': { value: upper },\n        'lower': { value: lower },\n        'capitalize': { value: capitalize },\n        'dict': { value: dict },\n        'dicti': { value: dicti },\n    });\n\nconst toLowerCase = x => ('' + x).toLowerCase();\nconst toUpperCase = x => ('' + x).toUpperCase();\n\nconst standardMapReplace = (whole, g1) => g1 === undefined ? whole : g1;\n\n/**\n    Try to match against one or more regular expressions.\n    \n    Match is designed to be used for declarations:\n    \n        const m = match()\n            .case(/ab(c)/)\n            .case(/ax/, x => x + x)\n            ...\n            .case(...);\n            \n    The result can then be applied to a generator.\n    \n        m(pep.str('abc'));\n        \n    Matches are on yielded values, use `pep.join` to match against all values.\n    \n    If no mapping function is provides, a successfully matched case returns \n    the first capture group of the match\n    \n    If a mapping function is provided, the function is invoked with the entire\n    string plus the match capture groups as arguments.\n*/\nconst match = module.exports.match = () => {\n    let cases = [];\n    const matcher = x => {\n        x = ('' + x);\n        for (const [matcher, replacer] of cases) {\n            const match = x.match(matcher);\n            if (match)\n                return replacer.apply(null, [x].concat(match.slice(1)));\n        }\n        return x;\n    };\n    \n    const self = g => pep.map(g, matcher);\n    self.case = (l, r = standardMapReplace) => {\n        cases.push([l, r]);\n        return self;\n    };\n    return self\n};\n\n/**\n    Run `String.prototype.replace` on the result of a generator.\n    \n    Curried because you usually want to save off the mapping\n    function as a named generator.\n        \n    @param target What to replace. Passed to String.prototype.replace\n    @param replacer How to replace. Passed to String.prototype.replace\n*/\nconst replace = module.exports.replace = (target, replacer) =>\n    match()\n        .case(target, x => x.replace(target, replacer));\n\n/**\n    Convert the result of `g` to upper case.\n*/\nconst upper = module.exports.upper = (g) =>\n    pep.map(g, toUpperCase);\n\n/**\n    Convert the result of `g` to lower case.\n*/\nconst lower = module.exports.lower = (g) =>\n    pep.map(g, toLowerCase);\n\n/**\n    Capitalize words in `g`.\n    \n    This is run for each yielded value. Use `pep.join` if you want proper\n    capitalization spanning yielded values:    \n    \n        const p = pep.seq('ab c', 'd ef');\n        \n        pep.run(capitalize(p)) === 'Ab CD Ef';\n        pep.run(capitalize(pep.join(p))) === 'Ab Cd Ef';\n*/\nconst capitalize = module.exports.capitalize =\n    replace(/\\b\\w/g, toUpperCase);\n\n/**\n    Case sensitive dictionary map function.\n    \n    Curried because you usually want to save off the mapping\n    function as a named generator.\n     \n    @param dictionary Object mapping string keys to values.\n    @param def Default value returned if non match is found\n*/\nconst dict = module.exports.dict = (dictionary, def = '') => {\n    const lookup = x =>\n        (dictionary.hasOwnProperty(x) ? dictionary[x] : def);\n    return (g) => pep.map(g, lookup);\n}\n\n/**\n    Case insensitive dictionary mapping.\n    \n    @see dict.\n*/\nconst dicti = module.exports.dicti = (dictionary, def = '') => {\n    const lookupTable = Object.keys(dictionary).reduce((p, c) => {\n        p[toLowerCase(c)] = dictionary[c];\n        return p;\n    }, {});\n\n    const lookup = x => {\n        const key = toLowerCase(x);\n        return (dictionary.hasOwnProperty(key) ? dictionary[key] : def);\n    };\n    \n    return (g) => pep.map(g, lookup);\n};"],"sourceRoot":"/source/"}